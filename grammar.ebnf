(* JACKAL formal grammar by spsandwichman 

    all words in UPPERCASE are jackal keywords. 
    {} indicates repetition (0 or more)
    [] indicates optionals (0 or 1)
    () indicates grouping
    things like "ident" and "literal" are not defined here but are assumed to exist

    some things like nested function decls, PUBLIC/EXPORT declarations in functions, etc.
    will be parsed as valid but eliminated during a semantic analysis phase.
*)

(* comma-separated list with optional trailing comma *)
list<X> = [X {"," X} [","]]

file = {decl}

storageclass = PUBLIC | PRIVATE | EXPORT

decl =
    | [storageclass] ident ":" type ["=" (expr | compoundexpr)]
    | [storageclass] ident ":" "=" (expr | compoundexpr)
    | [storageclass] fndecl
    | EXTERN ident ":" type     (* EXTERN parses differently so it cant go in storageclass *)
    | EXTERN FN fnproto 
    | typedecl

fnproto = ["(" type ")"] ident "(" list<param> ")" [":" type]
fndecl = FN fnproto {stmt} END
typedecl = 
    | STRUCT [PACKED] ident list<field> END
    | UNION ident list<field> END
    | ENUM ident ":" type list<variant> END
    | TYPE ident ":" type
    | FNPTR fnproto

param = (IN | OUT) field | "..." ident ident (* fn and fnptr *)
field = ident ":" type                       (* structs and unions *)
variant = ident | ident "=" expr             (* enums *)

assignop = 
    | "=" 
    | "+=" | "-=" | "*=" | "/=" | "%=" 
    | "&=" | "|=" | "$=" | "<<=" | ">>="

stmt = 
    | expr
    | expr assignop expr
    | decl
    | BARRIER
    | BREAK
    | CONTINUE
    | LEAVE
    | RETURN expr
    | "@" ident       (* label *)
    | GOTO ident
    | NOTHING         (* blank statement *)
    | IF expr THEN {stmt} (END | else)
    | WHILE expr DO {stmt} END

else = 
    | ELSEIF expr THEN {stmt} else
    | ELSE {stmt} END

binop =
    | "+" | "-" | "*" | "/" | "%" | "<<" | ">>" | "|" | "&" | "$"
    | "!=" | "==" | "<" | ">" | "<=" | ">=" | AND | OR

compoundexpr = 
    | "{" list<item> "}"
    | "{" list<expr> "}"

item = "[" expr "]" "=" expr


expr = 
    | expr binop expr         (* no precedence for now its ok *)
    | unary

unop =
    | "&" | "-" | "~" | NOT | SIZEOFVALUE

unary = 
    | CONTAINEROF expr TO type "." ident {"." ident}
    | CAST expr TO type
    | unop unary
    | atomic

atomic = 
    | ident | literal | TRUE | FALSE | NULLPTR
    | "(" expr ")"
    | OFFSETOF type "." ident
    | SIZEOF type
    | atomic "[" expr "]"
    | atomic "^"
    | atomic "." ident
    | atomic "(" list<argument> ")"

argument = [OUT] expr

type = 
    | basetype
    | basetype "[" expr "]"

basetype = 
    | QUAD | UQUAD | LONG | ULONG | INT | UINT | BYTE | UBYTE | VOID
    | ident
    | "(" type ")"
    | "^" basetype
